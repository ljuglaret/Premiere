<!DOCTYPE html>
<html>
    <head>
        <title> Cours 6 </title></head>
    <body><textarea theme="Journal">
# Nouvelles structures

Pour les utiliser vous aurez besoin des méthodes présentes dans la bibliothèque util de java

```java
import java.util.*;
```

## ArrayList

### Déclaration et utilisation 

```java

import java.util.* ;
class Main{
    ArrayList<Integer> l = new ArrayList<Integer>();
    public static void main (String[]args){}
}

```

### Méthodes
   
Ce que les ArrayList font que les tableaux ne font pas :  
- Supprimer une valeur selon son indice ou selon un condition. (removeIf)   
- Trier    (sort)
- Inverser  (reverse)
        
 Pour le reste il est toujours possible : 
- D ajouter une valeur. (add)
- De lire un element.   (get)

```java

import java.util.* ;

class Main{
    ArrayList<Integer> li = new ArrayList<Integer>();
    li.add(4); //li = {4}
    li.add(2); //li = {4 , 2}
    li.remove(0); //li = {2}
    li.add(3);//li = {2,3}
    li.add(-4);//li = {2,3,-4}
    li.add(1);//li = {2,3,-4,1}
    li.removeIf(n -> (n >= 2));//li = {-4,1}
    for (int e : li){
        System.out.print(e + " ");
    }
    Collections.reverse(li); // {1, -4}
    Collections.sort(li);//{-4 , 1}
}

```

### Entraînement

- Exercice 1    

On lance n dés m fois, quelle est la probabilité que la somme des n des soit supérieure ou égale à x.   

Exemple

x = 10
premier lancer
4 5 6 = somme = 15

second lancer
2  3 3 ; somme = 8   

Conclusion :
Une somme sur deux est inférieure à 15.
Une somme sur deux est supérieure à 15.


- Exercice 2   

<a href = https://www.codingame.com/training/easy/temperatures> Lien </a>



## HashMap

### Ce que c'est 

Une association de paires (Cles,Valeurs)  dans laquelle chaque clé est unique.


### Pourquoi est ce utile


### Attention

Chaque paire ne peut être présente qu'une seule et unique fois.

En effet si l'on écrit :

```java
    paysLangue.put("Suisse", "Francais");
    paysLangue.put("Suisse", "Anglais");
    paysLangue.put("Suisse", "Allemand");
```

La seule valeur associée à Suisse est Allemand.


Seule la dernière valeur sera prise en compte, pour contourner ce problème il faudra changer le type de HashMap, ce cas sera traite ulterieurement.

### Méthodes

- Vérifier si une clé existe : containsKey
- Accéder à la valeur d une  clé: get
- Supprimer une valeur associée à une clé :  remove
- Lire tous les paires de clés valeurs : entrySet

### Exemple    
   
```java
    HashMap<String,String>paysLangue  = new HashMap<String, String>();
```

Et pour ajouter des paires on utilise la méthode put

```java
    paysLangue.put("France", "Francais");
    paysLangue.put("Angleterre", "Anglais");

```
Methodes containsKey et get

```java
 if (paysLangue.containsKey("France")){
        System.out.println(paysLangue.get("France"));
    }
``` 

Parcours 

```java
    Set hset1 = paysLangue.entrySet();
    Iterator iterator = hset1.iterator();
    while(iterator.hasNext()){
      System.out.println(iterator.next());
    }

    // Avec un for : 
    for(Object stock : hset1){
        System.out.println(stock);
     }

```

Récuperer les clés 

```java
    Set hset2 = paysLangue.keySet();
    Iterator iterator2 = hset2.iterator();
    while(iterator2.hasNext()){
      System.out.println(iterator2.next());
    }

    // Ou directement
     for (String i : paysLangue.keySet()) {
      System.out.println( i );
    }
```

### Pour aller plus loin

Que peut on faire une fois arriver là?


Par exemple, on peut classer chaque paire selon l ordre lexicographique des clefs.   
Pour comprendre le fonctionnement regardons un cas particulier avec la lettre A.

```java

    public static void lettreA(HashMap<String,String> paysLangue){
    HashMap<String,String>paysLangueA  = new HashMap<String, String>();
    for (String i : paysLangue.keySet()) {
        if(i.charAt(0)== 'A'){
            paysLangueA.put(i,paysLangue.get(i));
        }
      }
      System.out.println(paysLangueA);
    }
```

Maintenant géneralisons.   
Pour simplifier nous allons remplacer chaque lettre par sa position dans l'alphabet :
```java
char A  = 'A';
int x   = (int)A - 65; // x = 65 - 65 = 0 
```


```java

    public static void general(HashMap<String,String> paysLangue){
     List<Map<String,String>>paysLangueClassement  = new ArrayList<Map<String,String>>();
     for(int k = 0 ; k < 25 ; k++){
        Map<String,String> m = new HashMap<String,String>();
     for (String i : paysLangue.keySet()) {
        if((int)i.charAt(0) - 65 == k){
            m.put(i,paysLangue.get(i));
        }
      }
      paysLangueClassement.add(k,m);
      System.out.print(paysLangueClassement.get(k));
    }
    }
```

### Cas plus complexe 

Pour le moment nous nous sommes limités a des HashMap de type <Type1, Type1>,
mais on peut aussi utiliser des types plus complexes comme <Type1, List<Type2>>.

Precédemment nous nous étions demandés comment gérer le cas dans lequel plusieurs langues étaient parlées dans un pays.


```java
    HashMap<String,List<String>>m = new HashMap<String, List<String>>();
    m.put("Suiss",Arrays.asList("Anglais", "Francais", "Allemand"));
```

### Application
<a href = the last crusade> Lien </a>   
Il s agit d'associer à un entier ( représentant le numéro de la pierre) la liste des sorties possibles correspondantes.

Le type sera donc 
```java
    HashMap<Integer,List<String>>m  = new HashMap<Integer,List<String>>();
```

</textarea>
        <script type="text/javascript" src="//lbesson.bitbucket.io/md/strapdown.min.js"></script>
    </body>
</html>
